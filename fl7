#!/usr/bin/env bash

usage() {
	echo "Usage $0 [-j] CODE" >&2
	exit 1
}

output_json=0

if [ "$1" = "-j" ]
then
  shift
  output_json=1
fi

(($# > 0)) || usage
exec=$1
shift

(($# > 0)) && usage

#

cd "$(cd "$(dirname "$0")"; pwd)"

if [ ! -f ./fluorite-7.js ]
then
	./compile.bash || exit 2
fi

export exec
export output_json
node -e "$(cat << 'END'
const fs = require("fs");
const source = process.env.exec;
const parser = require("./fluorite-7.js");
const result = parser.parse(source);

const env = new result.fl7c.Environment();
result.loadAliases(env);

const c = (key, value) => {
  var constantId = env.allocateConstantId();
  env.setAlias(key, new result.fl7c.FluoriteAliasConstant(constantId));
  env.setConstant(constantId, value);
};
c("IN", (function(){
  class FluoriteStreamerStdin extends result.fl7.FluoriteStreamer {

    constructor () {
      super();
    }

    start() { // TODO 徐々に読み込む
      var fd = process.stdin.fd;
      var strings = [];
      while (true) {
        var buffer = new Buffer(4096);
        var bytesRead;
        while (true) {
          try {
            bytesRead = fs.readSync(fd, buffer, 0, 4096, null);
          } catch (e) {
            if (e.code === "EAGAIN") {
              continue;
            } else {
              throw e;
            }
          }
          break;
        }
        if (bytesRead === 0) break;
        strings.push(buffer.toString('utf8', 0, bytesRead));
      }
      var input = strings.join("");
      var inputs = input.split("\n");
      var i = 0;
      return {
        next: () => {
          if (i >= inputs.length) return undefined;
          if (i == inputs.length - 1) {
            if (inputs[i] === "") {
              i++;
              return undefined;
            }
          }
          var result = inputs[i];
          i++;
          return result;
        },
      };
    }

  }
  return new FluoriteStreamerStdin();
})());

const code = result.node.getCode(env);

const util = result.fl7.util;
const constants = env.getConstants();
const stream = util.toStreamer(eval(code)).start();

if (process.env.output_json !== "0") {
  while (true) {
    const next = stream.next();
    if (next === undefined) break;
    console.log(JSON.stringify(next));
  }
} else {
  while (true) {
    const next = stream.next();
    if (next === undefined) break;
    console.log(util.toString(next));
  }
}

END
)"
