#!/usr/bin/env bash

usage() {
	echo "Usage $0 [-j] [-c] CODE" >&2
	exit 1
}

output_json=0
compile=0

if [ "$1" = "-j" ]
then
  shift
  output_json=1
fi

if [ "$1" = "-c" ]
then
  shift
  compile=1
fi

(($# > 0)) || usage
exec=$1
shift

(($# > 0)) && usage

#

app_dir=$(cd "$(dirname "$0")"; pwd)

if [ ! -f "$app_dir"/fluorite-7.js ]
then
  (
    cd "$app_dir"
    ./compile.bash
  ) || exit 2
fi

export exec
export output_json
export compile
export app_dir
export NODE_PATH="$NODE_PATH:$app_dir"
node -e "$(cat << 'END'
const fs = require("fs");
const child_process = require("child_process");
const parser = require(process.env.app_dir + "/fluorite-7.js");

let globalResult;

function parse(source) {

  const result = parser.parse(source);

  const env = new result.fl7c.Environment();
  result.loadAliases(env);
  const c = (key, value) => {
    var constantId = env.allocateConstantId();
    env.setAlias(key, new result.fl7c.FluoriteAliasConstant(constantId));
    env.setConstant(constantId, value);
  };
  c("IN", (function(){
    class FluoriteStreamerStdin extends result.fl7.FluoriteStreamer {

      constructor () {
        super();
      }

      start() { // TODO 徐々に読み込む

        var fd = process.stdin.fd;
        var buffers = [];
        var length = 0;
        while (true) {
          var buffer = new Buffer(4096);
          var bytesRead;
          while (true) {
            try {
              bytesRead = fs.readSync(fd, buffer, 0, 4096, null);
            } catch (e) {
              if (e.code === "EAGAIN") {
                continue;
              } else {
                throw e;
              }
            }
            break;
          }
          if (bytesRead === 0) break;
          buffers.push(buffer.subarray(0, bytesRead));
          length += bytesRead;
        }
        fs.closeSync(fd);

        const input = Buffer.concat(buffers, length).toString('utf8', 0, length);
        const inputs = input.split("\n");

        var i = 0;
        return {
          next: () => {
            if (i >= inputs.length) return undefined;
            if (i == inputs.length - 1) {
              if (inputs[i] === "") {
                i++;
                return undefined;
              }
            }
            var result = inputs[i];
            i++;
            return result;
          },
        };
      }

    }
    return new FluoriteStreamerStdin();
  })());
  c("READ", (function(){
    class FluoriteStreamerRead extends result.fl7.FluoriteStreamer {

      constructor (filename) {
        super();
        this._filename = filename;
      }

      start() { // TODO 徐々に読み込む

        var fd = fs.openSync(this._filename, "r");
        var buffers = [];
        var length = 0;
        while (true) {
          var buffer = new Buffer(4096);
          var bytesRead;
          while (true) {
            try {
              bytesRead = fs.readSync(fd, buffer, 0, 4096, null);
            } catch (e) {
              if (e.code === "EAGAIN") {
                continue;
              } else {
                throw e;
              }
            }
            break;
          }
          if (bytesRead === 0) break;
          buffers.push(buffer.subarray(0, bytesRead));
          length += bytesRead;
        }
        fs.closeSync(fd);

        const input = Buffer.concat(buffers, length).toString('utf8', 0, length);
        const inputs = input.split("\n");

        var i = 0;
        return {
          next: () => {
            if (i >= inputs.length) return undefined;
            if (i == inputs.length - 1) {
              if (inputs[i] === "") {
                i++;
                return undefined;
              }
            }
            var result = inputs[i];
            i++;
            return result;
          },
        };
      }

    }
    return new result.fl7.FluoriteFunction(args => {
      var filename = args[0];
      if (filename === undefined) throw new Error("Illegal argument");
      return new FluoriteStreamerRead(result.fl7.util.toString(filename));
    });
  })());
  c("WRITE", (function(){
    return new result.fl7.FluoriteFunction(args => {

      var filename = args[0];
      if (filename === undefined) throw new Error("Illegal argument");
      filename = result.fl7.util.toString(filename);

      var streamer = args[1];
      if (streamer === undefined) throw new Error("Illegal argument");
      streamer = result.fl7.util.toStream(streamer);

      const fd = fs.openSync(filename, "w");
      const stream = streamer.start();
      while (true) {
        const next = stream.next();
        if (next === undefined) break;
        fs.writeSync(fd, result.fl7.util.toString(next));
        fs.writeSync(fd, "\n");
      }
      fs.closeSync(fd);

      return null;
    });
  })());
  c("EXEC", new result.fl7.FluoriteFunction(args => {

    const filename = args[0];
    if (filename === undefined) throw new Error("Illegal argument");

    const argsExec = [];
    {
      let streamer = args[1];
      if (streamer === undefined) throw new Error("Illegal argument");
      streamer = result.fl7.util.toStream(streamer);
      const stream = streamer.start();
      while (true) {
        const next = stream.next();
        if (next === undefined) break;
        argsExec[argsExec.length] = result.fl7.util.toString(next);
      }
    }

    let stdin = args[2];
    if (stdin === undefined) throw new Error("Illegal argument");
    stdin = result.fl7.util.toString(stdin);

    const stringOut = child_process.execFileSync(filename, argsExec, {
      input: stdin,
      encoding: "utf8",
    });

    const arrayOut = stringOut.split("\n");
    if (arrayOut[arrayOut.length - 1] === "") arrayOut.pop();

    return result.fl7.util.toStreamFromArray(arrayOut);
  }));
  c("REQUIRE", (function(){
    return new result.fl7.FluoriteFunction(args => {
      var filename = args[0];
      if (filename === undefined) throw new Error("Illegal argument");

      var fd = fs.openSync(filename, "r");
      var buffers = [];
      var length = 0;
      while (true) {
        var buffer = new Buffer(4096);
        var bytesRead;
        while (true) {
          try {
            bytesRead = fs.readSync(fd, buffer, 0, 4096, null);
          } catch (e) {
            if (e.code === "EAGAIN") {
              continue;
            } else {
              throw e;
            }
          }
          break;
        }
        if (bytesRead === 0) break;
        buffers.push(buffer);
	length += bytesRead;
      }
      fs.closeSync(fd);

      const source = Buffer.concat(buffers, length).toString('utf8', 0, length);

      const result = parse(source);

      const fl7 = globalResult.fl7;
      const util = globalResult.fl7.util;
      const constants = globalResult.env.getConstants();
      return eval(result.code);
    });
  })());

  const codes = result.node.getCodeGetter(env);
  const code = "(function() {\n" + result.fl7c.util.indent(codes[0] + "return " + codes[1] + ";\n") + "}())";

  return {
    fl7: result.fl7,
    env: env,
    code: code,
  };
}

let result = parse(process.env.exec);
globalResult = result;

if (process.env.compile !== "0") {
  console.log(result.code);
} else {
  const fl7 = result.fl7;
  const util = result.fl7.util;
  const constants = result.env.getConstants();
  const stream = util.toStreamer(eval(result.code)).start();

  if (process.env.output_json !== "0") {
    while (true) {
      const next = stream.next();
      if (next === undefined) break;
      console.log(JSON.stringify(next));
    }
  } else {
    while (true) {
      const next = stream.next();
      if (next === undefined) break;
      console.log(util.toString(next));
    }
  }
}

END
)"
