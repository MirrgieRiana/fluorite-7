#!/usr/bin/env bash

usage() {
	echo "Usage $0 [-j] CODE" >&2
	exit 1
}

output_json=0

if [ "$1" = "-j" ]
then
  shift
  output_json=1
fi

(($# > 0)) || usage
exec=$1
shift

(($# > 0)) && usage

#

app_dir=$(cd "$(dirname "$0")"; pwd)

if [ ! -f "$app_dir"/fluorite-7.js ]
then
  (
    cd "$app_dir"
    ./compile.bash
  ) || exit 2
fi

export exec
export output_json
export app_dir
export NODE_PATH="$NODE_PATH:$app_dir"
node -e "$(cat << 'END'
const fs = require("fs");
const source = process.env.exec;
const parser = require(process.env.app_dir + "/fluorite-7.js");
const result = parser.parse(source);

const env = new result.fl7c.Environment();
result.loadAliases(env);

const c = (key, value) => {
  var constantId = env.allocateConstantId();
  env.setAlias(key, new result.fl7c.FluoriteAliasConstant(constantId));
  env.setConstant(constantId, value);
};
c("IN", (function(){
  class FluoriteStreamerStdin extends result.fl7.FluoriteStreamer {

    constructor () {
      super();
    }

    start() { // TODO 徐々に読み込む
      var fd = process.stdin.fd;
      var strings = [];
      while (true) {
        var buffer = new Buffer(4096);
        var bytesRead;
        while (true) {
          try {
            bytesRead = fs.readSync(fd, buffer, 0, 4096, null);
          } catch (e) {
            if (e.code === "EAGAIN") {
              continue;
            } else {
              throw e;
            }
          }
          break;
        }
        if (bytesRead === 0) break;
        strings.push(buffer.toString('utf8', 0, bytesRead));
      }
      var input = strings.join("");
      var inputs = input.split("\n");
      var i = 0;
      return {
        next: () => {
          if (i >= inputs.length) return undefined;
          if (i == inputs.length - 1) {
            if (inputs[i] === "") {
              i++;
              return undefined;
            }
          }
          var result = inputs[i];
          i++;
          return result;
        },
      };
    }

  }
  return new FluoriteStreamerStdin();
})());
c("READ", (function(){
  class FluoriteStreamerRead extends result.fl7.FluoriteStreamer {

    constructor (filename) {
      super();
      this._filename = filename;
    }

    start() { // TODO 徐々に読み込む
      var fd = fs.openSync(this._filename, "r");
      var strings = [];
      while (true) {
        var buffer = new Buffer(4096);
        var bytesRead;
        while (true) {
          try {
            bytesRead = fs.readSync(fd, buffer, 0, 4096, null);
          } catch (e) {
            if (e.code === "EAGAIN") {
              continue;
            } else {
              throw e;
            }
          }
          break;
        }
        if (bytesRead === 0) break;
        strings.push(buffer.toString('utf8', 0, bytesRead));
      }
      fs.closeSync(fd);
      var input = strings.join("");
      var inputs = input.split("\n");
      var i = 0;
      return {
        next: () => {
          if (i >= inputs.length) return undefined;
          if (i == inputs.length - 1) {
            if (inputs[i] === "") {
              i++;
              return undefined;
            }
          }
          var result = inputs[i];
          i++;
          return result;
        },
      };
    }

  }
  return new result.fl7.FluoriteFunction(args => {
    var filename = args[0];
    if (filename === undefined) throw new Error("Illegal argument");
    return new FluoriteStreamerRead(filename);
  });
})());

const codes = result.node.getCodeGetter(env);
const code = "(function() {\n" + result.fl7c.util.indent(codes[0] + "return " + codes[1] + ";\n") + "}())";

const util = result.fl7.util;
const constants = env.getConstants();
const stream = util.toStreamer(eval(code)).start();

if (process.env.output_json !== "0") {
  while (true) {
    const next = stream.next();
    if (next === undefined) break;
    console.log(JSON.stringify(next));
  }
} else {
  while (true) {
    const next = stream.next();
    if (next === undefined) break;
    console.log(util.toString(next));
  }
}

END
)"
